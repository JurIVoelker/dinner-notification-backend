package com.voelkerlabs.dinner_notification.controller

import com.voelkerlabs.dinner_notification.Constants
import com.voelkerlabs.dinner_notification.dto.NotificationRatingResponseDTO
import com.voelkerlabs.dinner_notification.dto.NotificationRequestDTO
import com.voelkerlabs.dinner_notification.exception.UnexpectedNullAutogeneratedException
import com.voelkerlabs.dinner_notification.model.Notification
import com.voelkerlabs.dinner_notification.model.NotificationStatus
import com.voelkerlabs.dinner_notification.model.firebase.FirebaseDinnerNotificationMessage
import com.voelkerlabs.dinner_notification.service.FirebaseService
import com.voelkerlabs.dinner_notification.service.NotificationService
import com.voelkerlabs.dinner_notification.service.UserService
import jakarta.validation.Valid
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import java.time.Instant

@RestController
class NotificationController @Autowired constructor(
    private val firebaseService: FirebaseService,
    private val userService: UserService,
    private val notificationService: NotificationService
) {
    @PostMapping("/notifications")
    fun sendNotifications(@RequestBody @Valid body: NotificationRequestDTO): List<Notification> {
        val users = userService.findByIdsNotNull(body.userIds)

        val notificationList = mutableListOf<Notification>()

        users.forEach { user ->
            user.id ?: throw UnexpectedNullAutogeneratedException()
            val notification = Notification(
                notificationStatus = NotificationStatus.PENDING,
                notificationFrom = body.notificationFrom,
                notificationTo = user.id,
            )
            try {
                firebaseService.sendMessage(
                    FirebaseDinnerNotificationMessage(
                        user.fcmToken,
                        notification.createdAt ?: Instant.now(),
                        notification.notificationFrom,
                        Constants.NOTIFICATION_EXPIRY_MILLISECONDS
                    )
                )
            } catch (_: Exception) {
                notification.notificationStatus = NotificationStatus.ERROR
            }
            notificationService.save(notification)
            notificationList.add(notification)
        }
        return notificationList
    }

    @GetMapping("/notifications/me")
    fun getOwnNotifications(@RequestParam(value = "id") userId: Long): List<Notification> {
        val rawNotifications = notificationService.findNotificationsByNotificationTo(userId)
        notificationService.markExpiredNotifications(rawNotifications)
        val unexpiredNotifications = notificationService.markPendingNotificationsAsReceived(rawNotifications)
        return unexpiredNotifications
    }

    @PutMapping("/notifications/accept")
    fun acceptNotification(@RequestParam(value = "id") notificationId: Long): NotificationRatingResponseDTO {
        return notificationService.handleNotificationRating(notificationId, NotificationStatus.ACCEPTED)
    }

    @PutMapping("/notifications/decline")
    fun declineNotification(@RequestParam(value = "id") notificationId: Long): NotificationRatingResponseDTO {
        return notificationService.handleNotificationRating(notificationId, NotificationStatus.DECLINED)
    }

    @GetMapping("/notifications/trace")
    fun traceNotifications(@RequestParam(value = "id") userId: Long): List<Notification> {
        val userNotifications = notificationService.findByNotificationsFrom(userId)
        val unexpiredNotifications = notificationService.getUnexpiredNotifications(userNotifications)
        return unexpiredNotifications
    }
}